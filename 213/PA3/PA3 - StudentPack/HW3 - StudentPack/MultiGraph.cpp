#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    return w0*alpha + w1*(1-alpha);
}
int MultiGraph::findVertex(const std::string& vertexName)const
{
    /* TODO */
    int ind = -1;
    for(int i = 0; i < vertexList.size(); i++){
        if(vertexList[i].name  == vertexName){
            ind = i;
        }
    }
    return ind;
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    /* TODO */
   
        if(findVertex(vertexName) != -1){
            throw DuplicateVertexException(vertexName);
        }
    
    GraphVertex vert;
    vert.name = vertexName;
    vertexList.push_back(vert);
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    /* TODO */
    int ind = -1;
    if((ind = findVertex(vertexName)) == -1){
            throw VertexNotFoundException(vertexName);
        }
    
    vertexList.erase(vertexList.begin() + ind);
     
    for(int i = 0; i < vertexList.size(); i++){
        for(int j = 0; j < vertexList[i].edges.size(); j++){
            if(vertexList[i].edges[j].endVertexIndex  == ind){
                vertexList[i].edges.erase(vertexList[i].edges.begin() + j); 
                j--;
            }
            else if(vertexList[i].edges[j].endVertexIndex  > ind){
                vertexList[i].edges[j].endVertexIndex = vertexList[i].edges[j].endVertexIndex -1; 
            }
        }
    }

}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
     int ind1 = findVertex(vertexFromName);
     int ind2 = findVertex(vertexToName);
    if(ind1 == -1 || ind2 == -1){
        if(ind1 == -1)
            throw VertexNotFoundException(vertexFromName);
        else throw VertexNotFoundException(vertexToName);
        }
    for(int j = 0; j < vertexList[ind1].edges.size(); j++){
        if( vertexList[ind1].edges[j].endVertexIndex == ind2 && vertexList[ind1].edges[j].name == edgeName && vertexList[ind1].edges[j].weight[0] == weight0 && vertexList[ind1].edges[j].weight[1] == weight1){
            throw SameNamedEdgeException(edgeName, vertexFromName, vertexToName);
        }
    }
    GraphEdge edge;
    edge.name = edgeName;
    edge.weight[0] = weight0;
    edge.weight[1] = weight1;
    edge.endVertexIndex = ind2;
    vertexList[ind1].edges.push_back(edge);

}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    /* TODO */
     int ind1 = findVertex(vertexFromName);
     int ind2 = findVertex(vertexToName);
     int j = 0;
    if(ind1 == -1 || ind2 == -1){
        if(ind1 == -1)
            throw VertexNotFoundException(vertexFromName);
        else throw VertexNotFoundException(vertexToName);
        }
    bool found = false;
     for(j = 0; j < vertexList[ind1].edges.size(); j++){
        if( vertexList[ind1].edges[j].endVertexIndex == ind2 && vertexList[ind1].edges[j].name == edgeName){
            found = true;
            break;
        }
    }
    if(!found){
        throw EdgeNotFoundException(vertexFromName,edgeName);
    }
    vertexList[ind1].edges.erase(vertexList[ind1].edges.begin()+j);
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    /* TODO */
     int ind1 = findVertex(vertexNameFrom);
     int ind2 = findVertex(vertexNameTo);
     int j = 0;
    if(ind1 == -1 || ind2 == -1){
        if(ind1 == -1)
            throw VertexNotFoundException(vertexNameFrom);
        else throw VertexNotFoundException(vertexNameTo);
        }

    bool found = false;
    float beta = 0.0;
     Pair<int,int> intPair;
     intPair.key = -1; intPair.value = -1;
    std::vector<float> distance(vertexList.size(), 99999999);
    std::vector<Pair<int,int>> previous(vertexList.size(), intPair); 
    MinPairHeap<float, int> pq;
    Pair<float,int> pair;
     Pair<float,int> extPair;
    
    pair.key = 0.0;
    pair.value = ind1;
    pq.push(pair);
    while(!pq.empty()){
        pair = pq.top();
        pq.pop();
        if(pair.value == ind2){
                found = true;
                break;
            }
        for(int i = 0; i < vertexList[pair.value].edges.size(); i++){
            
            beta = pair.key + Lerp(vertexList[pair.value].edges[i].weight[0],vertexList[pair.value].edges[i].weight[1], heuristicWeight);
            if(beta < distance[vertexList[pair.value].edges[i].endVertexIndex]){
                distance[vertexList[pair.value].edges[i].endVertexIndex] = beta;
                intPair.key = pair.value;
                intPair.value = i;
                previous[distance[vertexList[pair.value].edges[i].endVertexIndex]] = intPair;
                extPair.key = beta;
                extPair.value = vertexList[pair.value].edges[i].endVertexIndex;
                pq.push(extPair);
            }
        }
    }
    std::vector<int> temp;
    int ind = ind2;
    if(found){ 
        for(int j = 0; j < previous.size(); j++){
            intPair = previous[ind];
            ind = intPair.key;
            temp.push_back(intPair.value);
            temp.push_back(intPair.key);
        }
      
        for(int j = temp.size() - 1; j > -1; j--){
             orderedVertexEdgeIndexList.push_back(temp[j]);
        }
           orderedVertexEdgeIndexList.push_back(ind2);
        return true;}
    return false;
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    /* TODO */
     /* TODO */
     int ind1 = findVertex(vertexNameFrom);
     int ind2 = findVertex(vertexNameTo);
     int j = 0;
    if(ind1 == -1 || ind2 == -1){
        if(ind1 == -1)
            throw VertexNotFoundException(vertexNameFrom);
        else throw VertexNotFoundException(vertexNameTo);
        }

    bool found = false;
    bool isIn = false;
    float beta = 0.0;
     Pair<int,int> intPair;
     intPair.key = -1; intPair.value = -1;
    std::vector<float> distance(vertexList.size(), 99999999);
    std::vector<Pair<int,int>> previous(vertexList.size(), intPair); 
    MinPairHeap<float, int> pq;
    Pair<float,int> pair;
     Pair<float,int> extPair;
    
    pair.key = 0.0;
    pair.value = ind1;
    pq.push(pair);
    while(!pq.empty()){
        pair = pq.top();
        pq.pop();
        if(pair.value == ind2){
                found = true;
                break;
            }
        for(int i = 0; i < vertexList[pair.value].edges.size(); i++){
            isIn = false;
            for(int j = 0; j < edgeNames.size(); j++){
                if(edgeNames[j] == vertexList[pair.value].edges[i].name) isIn= true;
            }
            if(!isIn){
                beta = pair.key + Lerp(vertexList[pair.value].edges[i].weight[0],vertexList[pair.value].edges[i].weight[1], heuristicWeight);
                if(beta < distance[vertexList[pair.value].edges[i].endVertexIndex]){
                    distance[vertexList[pair.value].edges[i].endVertexIndex] = beta;
                    intPair.key = pair.value;
                    intPair.value = i;
                    previous[distance[vertexList[pair.value].edges[i].endVertexIndex]] = intPair;
                    extPair.key = beta;
                    extPair.value = vertexList[pair.value].edges[i].endVertexIndex;
                    pq.push(extPair);
                }
            }
        }
    }
    std::vector<int> temp;
    int ind = ind2;
    if(found){ 
        for(int j = 0; j < previous.size(); j++){
            intPair = previous[ind];
            ind = intPair.key;
            temp.push_back(intPair.value);
            temp.push_back(intPair.key);
        }
      
        for(int j = temp.size() - 1; j > -1; j--){
             orderedVertexEdgeIndexList.push_back(temp[j]);
        }
           orderedVertexEdgeIndexList.push_back(ind2);
        return true;}
    return false;
}

int MultiGraph::BiDirectionalEdgeCount() const
{
    /* TODO */
    

    return -1;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{
    /* TODO */
    int ind = findVertex(vertexName);
    bool isIn = false;
      if(ind == -1){
        throw VertexNotFoundException(vertexName);
    }
    return -1;

    Pair<int,int> p1;
    Pair<int,int> p2;
    p2.key = 0; p2.value = ind;
    MinPairHeap<int,int> pq;
    std::vector<int> path_length(vertexList.size(),-1);
    path_length[ind] = 0;
    std::vector<int> visited;

    visited.push_back(ind);

    pq.push(p2);
    while(!pq.empty()){
        p1 = pq.top();
        pq.pop();
        for(int i = 0; i < vertexList[p1.value].edges.size(); i++){
            isIn = false;
            for(int j = 0; j < visited.size(); j++){
                if(visited[j] == vertexList[p1.value].edges[i].endVertexIndex){
                    isIn = true;
                }
            }
            if(!isIn){
                p2.key = p2.key +1;
                p2.value = vertexList[p1.value].edges[i].endVertexIndex;
                pq.push(p2);
                visited.push_back(vertexList[p1.value].edges[i].endVertexIndex);
                path_length[vertexList[p1.value].edges[i].endVertexIndex] = path_length[p1.value] + 1;
            }

        }
    }
    int count = 0;
    for(int i = 0; i < path_length.size(); i++){
            if(path_length[i] > count){
                count = path_length[i];
            }
    }
    return count;

}